В PHP разавито ООП на уровне Java/C#: interface, abstract class, class, implements, extends, private, public, protected
Помимо развитого ООП в PHP поддерживаются Трейты (trait), они же примиси или миксины
На PHP можно писать в функциональном стиле, есть функции высшего порядка, замыкания, map/filter/reduce, есть книга с описанием продвинутых техник (аппликативы, функторы, монады): "Functional Programming in PHP" http://www.functionalphp.com/
Анонимные функции появились в PHP на 5 лет раньше, чем в Java: июнь 2009 PHP 5.3 vs март 2014 Java 8
На каждый запрос PHP очищает окружение, мы видим только параметры и тело пришедшего запрос, нет никакого глобального состояния приложения, идеальный иммутабельный сервис для обработки http запросов!
Отедльно взятый запрос обрабатывается однопоточно, но PHP-FPM (FastCGI Process Manager) сам запустит столько воркеров, сколько нужно (в сконфигурированных рамках) для обработки приходящих параллельно запросов
Массивы передаются в функции по значению - это удобно и иммутабельно
Есть деструктуризация, в том числе вложенных структур ключ=>значение ``[['x' => $a, 'y' => $b], ['x' => $c, 'y' => $d]] = [['x' => 1, 'y' => 2], ['x' => 3, 'y' => 4]];``
Работа с файлами, сетью, юникодом, большими числами т.д. (т.е. стандартная библиотека) - это тонкая прослойка к Си библиотекам, что работает быстро
Можно писать свои расширения для PHP на языках C, Go, Rust (высокопроизводительные участки кода), а затем использовать PHP как высокоуровневый DSL
Регулярные выражения в PHP под капотом используют проверенную временем библиотеку PCRE (http://www.pcre.org), что гораздо быстрее, чем собственные реализации в других языках (например Go) http://benchmarksgame.alioth.debian.org/u64q/performance.php?test=regexdna
В PHP есть специальная оптимизация для работы с MySQL: чтобы уменьшить количество копирований памяти между процессами разработчики PHP отказались от использования libmysql (стандартная библиотека-клиент), реализовав так называемый MySQL Native Driver. Было: MySQL -> libmysql -> память процесса PHP; Стало: MySQL -> память процесса PHP http://jpauli.github.io/2014/07/21/php-and-mysql-communication-mysqlnd.html
Для PHP всегда найдётся актуальный драйвер к вашей любимой СУБД: MySQL, PostgreSQL, SQL Server, Oracle, Firebird, Informix, DB2, SQLLite, MongoDB, Redis, RethinkDB...
Doctrine - мощная и самая популярная ORM для PHP, которая элегантно реализует многие идеи из Hibernate (Java) https://ru.wikipedia.org/wiki/Doctrine
В PHP строки можно использовать как массив байт, как в Python 2. В Python 3 это поменялось - строки стали юникодными, а для работы с байтами используйте отдельный тип, что вызвало не мало проблем при переходе, усугубило раскол сообщества. В PHP тоже планировали так сделать (в невышедшей версии PHP 6), но не сделали! Работать с юникод строками можно через специальный набор функций, например strlen() vs mb_strlen()
PHP - язык с динамической типизацией, но вы можете расставить типы перед аргументами функций и указать типы возвращаемых значений (включая примитивные типы, интерфейсы и классы), тем самым получив все преимущества статически-типизированных языков. В добавок, если указать конструкцию ``declare(strict_types=1)``, типизация станет ещё и строгой (без приведения int -> float и т.п.)!
PhpStorm - это IDE основанная на Intellij IDEA, которая по богатсву фич и поддержке экосистемы языка уступает лишь самой IDEA для Java. Остальные продукты в линейке (WebStorm, RubyMine, PyCharm) явно уступают, в том числе из-за сложности статического анализа очень уж динамических языков JavaScript, Ruby и Python. В плане возможностей для статического анализа PHP ближе к Java.
Существует заблуждение, что на каждый запрос PHP заново интерпретирует весь код скприта. На самом при первом обращении PHP читает ваши исходники, компилирует их в байт-код и сохраняет в памяти. При последующих обращениях используется уже закешированный байт-код, если файлы исходников не обвились. По умолчанию проверка исходников на наличие новых происходит не чаще чем раз 2 секунды, можно вообще отключить и всегда использовать скомпилированный заранее байт-код.